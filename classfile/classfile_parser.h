#pragma once
//
// Created by ya on 2022/2/28.
//

#ifndef TINY_JVM_CLASSFILE_PARSER_H
#define TINY_JVM_CLASSFILE_PARSER_H

#include <iostream>
#include <fstream>
#include <vector>
#include "types.h"
#include "String.h"
#include <unordered_map>

using namespace std;
#define ACC_PUBLIC        0x0001            // can be visited by all (CFMI)
#define ACC_PRIVATE        0x0002            // cannot be visited by all (FMI)
#define ACC_PROTECTED    0x0004            // cannot be visited by this (FMI)
#define ACC_STATIC        0x0008            // static (FMI)
#define ACC_FINAL        0x0010            // cannot have a child class (CFMI)
#define ACC_SUPER        0x0020            // when the `invokespecial` instruction used, the father class's method should be treated specially (C)
#define ACC_SYNCHRONIZED    0x0020            // method was synchornized by **monitor** (M)
#define ACC_VOLATILE        0x0040            // volatile (fragile) (F)
#define ACC_BRIDGE        0x0040            // method was generated by compiler (M)
#define ACC_TRANSIENT    0x0080            // cannot be serialized (F)
#define ACC_VARARGS        0x0080            // method has va_args (M)
#define ACC_NATIVE        0x0100            // method is native (M)
#define ACC_INTERFACE    0x0200            // this is an interface, otherwise a class (CI)
#define ACC_ABSTRACT        0x0400            // cannot be instantiation (CMI)
#define ACC_STRICT        0x0800            // method uses **strictfp**, strictfp float format (M)
#define ACC_SYNTHETIC    0x1000            // the code is not generalized by java (by compiler but not the coder) (CFMI)
#define ACC_ANNOTATION    0x2000            // this is an annotation like @Override. at the same time the `ACC_INTERFACE` should also be settled (CI)
#define ACC_ENUM            0x4000            // this is an enum like enum {...} (CFI)
#define ACC_MANDATED        0x8000

static std::unordered_map<u1, std::pair<std::string, int>> bccode_map{    // pair<bccode_name, bccode_eat_how_many_arguments>
        {0x00, {"nop",             0}},
        {0x01, {"aconst_null",     0}},
        {0x02, {"iconst_m1",       0}},
        {0x03, {"iconst_0",        0}},
        {0x04, {"iconst_1",        0}},
        {0x05, {"iconst_2",        0}},
        {0x06, {"iconst_3",        0}},
        {0x07, {"iconst_4",        0}},
        {0x08, {"iconst_5",        0}},
        {0x09, {"lconst_0",        0}},
        {0x0a, {"lconst_1",        0}},
        {0x0b, {"fconst_0",        0}},
        {0x0c, {"fconst_1",        0}},
        {0x0d, {"fconst_2",        0}},
        {0x0e, {"dconst_0",        0}},
        {0x0f, {"dconst_1",        0}},
        {0x10, {"bipush",          1}},
        {0x11, {"sipush",          2}},
        {0x12, {"ldc",             1}},
        {0x13, {"ldc_w",           2}},
        {0x14, {"ldc2_w",          2}},
        {0x15, {"iload",           1}},
        {0x16, {"lload",           1}},
        {0x17, {"fload",           1}},
        {0x18, {"dload",           1}},
        {0x19, {"aload",           1}},
        {0x1a, {"iload_0",         0}},
        {0x1b, {"iload_1",         0}},
        {0x1c, {"iload_2",         0}},
        {0x1d, {"iload_3",         0}},
        {0x1e, {"lload_0",         0}},
        {0x1f, {"lload_1",         0}},
        {0x20, {"lload_2",         0}},
        {0x21, {"lload_3",         0}},
        {0x22, {"fload_0",         0}},
        {0x23, {"fload_1",         0}},
        {0x24, {"fload_2",         0}},
        {0x25, {"fload_3",         0}},
        {0x26, {"dload_0",         0}},
        {0x27, {"dload_1",         0}},
        {0x28, {"dload_2",         0}},
        {0x29, {"dload_3",         0}},
        {0x2a, {"aload_0",         0}},
        {0x2b, {"aload_1",         0}},
        {0x2c, {"aload_2",         0}},
        {0x2d, {"aload_3",         0}},
        {0x2e, {"iaload",          0}},
        {0x2f, {"laload",          0}},
        {0x30, {"faload",          0}},
        {0x31, {"daload",          0}},
        {0x32, {"aaload",          0}},
        {0x33, {"baload",          0}},
        {0x34, {"caload",          0}},
        {0x35, {"saload",          0}},
        {0x36, {"istore",          1}},
        {0x37, {"lstore",          1}},
        {0x38, {"fstore",          1}},
        {0x39, {"dstore",          1}},
        {0x3a, {"astore",          1}},
        {0x3b, {"istore_0",        0}},
        {0x3c, {"istore_1",        0}},
        {0x3d, {"istore_2",        0}},
        {0x3e, {"istore_3",        0}},
        {0x3f, {"lstore_0",        0}},
        {0x40, {"lstore_1",        0}},
        {0x41, {"lstore_2",        0}},
        {0x42, {"lstore_3",        0}},
        {0x43, {"fstore_0",        0}},
        {0x44, {"fstore_1",        0}},
        {0x45, {"fstore_2",        0}},
        {0x46, {"fstore_3",        0}},
        {0x47, {"dstore_0",        0}},
        {0x48, {"dstore_1",        0}},
        {0x49, {"dstore_2",        0}},
        {0x4a, {"dstore_3",        0}},
        {0x4b, {"astore_0",        0}},
        {0x4c, {"astore_1",        0}},
        {0x4d, {"astore_2",        0}},
        {0x4e, {"astore_3",        0}},
        {0x4f, {"iastore",         0}},
        {0x50, {"lastore",         0}},
        {0x51, {"fastore",         0}},
        {0x52, {"dastore",         0}},
        {0x53, {"aastore",         0}},
        {0x54, {"bastore",         0}},
        {0x55, {"castore",         0}},
        {0x56, {"sastore",         0}},
        {0x57, {"pop",             0}},
        {0x58, {"pop2",            0}},
        {0x59, {"dup",             0}},
        {0x5a, {"dup_x1",          0}},
        {0x5b, {"dup_x2",          0}},
        {0x5c, {"dup2",            0}},
        {0x5d, {"dup2_x1",         0}},
        {0x5e, {"dup2_x2",         0}},
        {0x5f, {"swap",            0}},
        {0x60, {"iadd",            0}},
        {0x61, {"ladd",            0}},
        {0x62, {"fadd",            0}},
        {0x63, {"dadd",            0}},
        {0x64, {"isub",            0}},
        {0x65, {"lsub",            0}},
        {0x66, {"fsub",            0}},
        {0x67, {"dsub",            0}},
        {0x68, {"imul",            0}},
        {0x69, {"lmul",            0}},
        {0x6a, {"fmul",            0}},
        {0x6b, {"dmul",            0}},
        {0x6c, {"idiv",            0}},
        {0x6d, {"ldiv",            0}},
        {0x6e, {"fdiv",            0}},
        {0x6f, {"ddiv",            0}},
        {0x70, {"irem",            0}},
        {0x71, {"lrem",            0}},
        {0x72, {"frem",            0}},
        {0x73, {"drem",            0}},
        {0x74, {"ineg",            0}},
        {0x75, {"lneg",            0}},
        {0x76, {"fneg",            0}},
        {0x77, {"dneg",            0}},
        {0x78, {"ishl",            0}},
        {0x79, {"lshl",            0}},
        {0x7a, {"ishr",            0}},
        {0x7b, {"lshr",            0}},
        {0x7c, {"iushr",           0}},
        {0x7d, {"lushr",           0}},
        {0x7e, {"iand",            0}},
        {0x7f, {"land",            0}},
        {0x80, {"ior",             0}},
        {0x81, {"lor",             0}},
        {0x82, {"ixor",            0}},
        {0x83, {"lxor",            0}},
        {0x84, {"iinc",            2}},
        {0x85, {"i2l",             0}},
        {0x86, {"i2f",             0}},
        {0x87, {"i2d",             0}},
        {0x88, {"l2i",             0}},
        {0x89, {"l2f",             0}},
        {0x8a, {"l2d",             0}},
        {0x8b, {"f2i",             0}},
        {0x8c, {"f2l",             0}},
        {0x8d, {"f2d",             0}},
        {0x8e, {"d2i",             0}},
        {0x8f, {"d2l",             0}},
        {0x90, {"d2f",             0}},
        {0x91, {"i2b",             0}},
        {0x92, {"i2c",             0}},
        {0x93, {"i2s",             0}},
        {0x94, {"lcmp",            0}},
        {0x95, {"fcmpl",           0}},
        {0x96, {"fcmpg",           0}},
        {0x97, {"dcmpl",           0}},
        {0x98, {"dcmpg",           0}},
        {0x99, {"ifeq",            2}},
        {0x9a, {"ifne",            2}},
        {0x9b, {"iflt",            2}},
        {0x9c, {"ifge",            2}},
        {0x9d, {"ifgt",            2}},
        {0x9e, {"ifle",            2}},
        {0x9f, {"if_icmpeq",       2}},
        {0xa0, {"if_icmpne",       2}},
        {0xa1, {"if_icmplt",       2}},
        {0xa2, {"if_icmpge",       2}},
        {0xa3, {"if_icmpgt",       2}},
        {0xa4, {"if_icmple",       2}},
        {0xa5, {"if_acmpeq",       2}},
        {0xa6, {"if_acmpne",       2}},
        {0xa7, {"goto",            2}},
        {0xa8, {"jsr",             2}},
        {0xa9, {"ret",             1}},
        {0xaa, {"tableswitch",     -1}},        // va_args
        {0xab, {"lookupswitch",    -2}},    // va_args
        {0xac, {"ireturn",         0}},
        {0xad, {"lreturn",         0}},
        {0xae, {"freturn",         0}},
        {0xaf, {"dreturn",         0}},
        {0xb0, {"areturn",         0}},
        {0xb1, {"return",          0}},
        {0xb2, {"getstatic",       2}},
        {0xb3, {"putstatic",       2}},
        {0xb4, {"getfield",        2}},
        {0xb5, {"putfield",        2}},
        {0xb6, {"invokevirtual",   2}},
        {0xb7, {"invokespecial",   2}},
        {0xb8, {"invokestatic",    2}},
        {0xb9, {"invokeinterface", 4}},    // 4.
        {0xba, {"invokedynamic",   4}},    // 4.
        {0xbb, {"new",             2}},
        {0xbc, {"newarray",        1}},
        {0xbd, {"anewarray",       2}},
        {0xbe, {"arraylength",     0}},
        {0xbf, {"athrow",          0}},
        {0xc0, {"checkcast",       2}},
        {0xc1, {"instanceof",      2}},
        {0xc2, {"monitorenter",    0}},
        {0xc3, {"monitorexit",     0}},
        {0xc4, {"wide",            -3}},            // length 3 or 5. [extend local variable index]
        {0xc5, {"multianewarray",  3}},    // 3.
        {0xc6, {"ifnull",          2}},
        {0xc7, {"ifnonnull",       2}},
        {0xc8, {"goto_w",          4}},            // 4.
        {0xc9, {"jsr_w",           4}},            // 4.
        {0xca, {"breakpoint",      0}},
        {0xfe, {"impdep1",         0}},
        {0xff, {"impdep2",         0}},
};
class ClassReader {
public:
    ClassReader(const string &filePath) : dataStream_(filePath, std::ios::binary) {}

    u2 peek2() {
        u1 first = dataStream_.get();
        u1 second = dataStream_.peek();
        dataStream_.unget();
        return ((first << 8) + second) & 0xFFFF;
    }

    u1 readUint8() {
        u1 result;
        dataStream_.read((char *) &result, sizeof(u1));
        return result;
    }

    u2 readUint16() {
        u2 result;
        dataStream_.read((char *) &result, sizeof(u2));
        return htons(result);
    }

    u4 readUint32() {
        u4 result;
        dataStream_.read((char *) &result, sizeof(u4));
        return htonl(result);
    }

    u1 *readBytes(int n) {
        u1 *bytes = new u1[n];
        for (int i = 0; i < n; ++i) {
            bytes[i] = readUint8();
        }
        return bytes;
    }

    void readUTF(unsigned char *bytes, int length) {
        dataStream_.read((char *) bytes, length);
    }

private:
    std::ifstream dataStream_;
};

//=====
#define CONSTANT_Class                7
#define CONSTANT_Fieldref            9
#define CONSTANT_Methodref            10
#define CONSTANT_InterfaceMethodref    11
#define CONSTANT_String                8
#define CONSTANT_Integer                3
#define CONSTANT_Float                4
#define CONSTANT_Long                5
#define CONSTANT_Double                6
#define CONSTANT_NameAndType            12
#define CONSTANT_Utf8                1
#define CONSTANT_MethodHandle        15
#define CONSTANT_MethodType            16
#define CONSTANT_InvokeDynamic        18

class CONSTANT_String_info;

class Constant {
public:
    int tag;

    Constant(ClassReader &reader, int tag_) : reader(reader), tag(tag_) {}


protected:
    ClassReader &reader;
};

class CONSTANT_Class_info : public Constant {            // Class, String

public:
    CONSTANT_Class_info(ClassReader &reader) : Constant(reader, CONSTANT_Class) {
        index = reader.readUint16();
    }

    u2 index;
};

class CONSTANT_String_info : public Constant {            // Class, String

public:
    CONSTANT_String_info(ClassReader &reader) : Constant(reader, CONSTANT_String) {
        index = reader.readUint16();
    }

    u2 index;
};


class CONSTANT_FMI_info : public Constant {        // Field, Methodref, InterfaceMethodref

public:
    CONSTANT_FMI_info(ClassReader &reader, int tag) : Constant(reader, tag) {
        class_index = reader.readUint16();
        name_and_type_index = reader.readUint16();
    }

    u2 class_index;
    u2 name_and_type_index;
};

class ConstantMethodref_info : public CONSTANT_FMI_info {
public:
    ConstantMethodref_info(ClassReader &reader) : CONSTANT_FMI_info(reader, CONSTANT_Methodref) {
    };
};

class ConstantInterfaceMethodref_info : public CONSTANT_FMI_info {
public:
    ConstantInterfaceMethodref_info(ClassReader &reader) : CONSTANT_FMI_info(reader, CONSTANT_InterfaceMethodref) {
    };
};

class ConstantFieldref_info : public CONSTANT_FMI_info {
public:
    ConstantFieldref_info(ClassReader &reader) : CONSTANT_FMI_info(reader, CONSTANT_Fieldref) {
    };
};

class CONSTANT_Integer_info : public Constant {       // Integer
public:
    CONSTANT_Integer_info(ClassReader &reader) : Constant(reader, CONSTANT_Integer) {
        bytes = reader.readUint32();
    }

    u4 bytes;

    int get_value() {
        return (int) bytes;
    }
};

#define FLOAT_INFINITY            0x7f800000
#define FLOAT_NEGATIVE_INFINITY    0xff800000
#define FLOAT_NAN                0x7f880000
// define by myself
#define DOUBLE_INFINITY            0x7ff0000000000000L
#define DOUBLE_NEGATIVE_INFINITY    0xfff0000000000000L
#define DOUBLE_NAN                0x7ff8000000000000L


// constant pool: MethodHandle
#define REF_getField                    1
#define REF_getStatic                2
#define REF_putField                    3
#define REF_putStatic                4
#define REF_invokeVirtual            5
#define REF_invokeStatic                6
#define REF_invokeSpecial            7
#define REF_newInvokeSpecial            8
#define REF_invokeInterface            9

struct CONSTANT_Float_info : public Constant {       // Float
private:
    u4 bytes;

public:
    CONSTANT_Float_info(ClassReader &reader) : Constant(reader, CONSTANT_Float) {
        bytes = reader.readUint32();
    }

    float get_value() {
        if (bytes == FLOAT_INFINITY) return FLOAT_INFINITY;
        else if (bytes == FLOAT_NEGATIVE_INFINITY) return FLOAT_NEGATIVE_INFINITY;
        else if ((bytes >= 0x7f800001 && bytes <= 0x7fffffff) || (bytes >= 0xff800001 && bytes <= 0xffffffff))
            return FLOAT_NAN;
        else {
            int s = ((bytes >> 31) == 0) ? 1 : -1;
            int e = ((bytes >> 23) & 0xff);
            int m = (e == 0) ? (bytes & 0x7fffff) << 1 : (bytes & 0x7fffff) | 0x800000;        // $ 4.4.4
            return s * m * pow(2, e - 150);
        }
    }
};

struct CONSTANT_Long_info : public Constant {       // Long
private:
    u4 high_bytes;
    u4 low_bytes;

public:
    CONSTANT_Long_info(ClassReader &reader) : Constant(reader, CONSTANT_Long) {
        high_bytes = reader.readUint32();
        low_bytes = reader.readUint32();
    }

    long get_value() {
        return ((long) high_bytes << 32) + low_bytes;
    }
};

class CONSTANT_Double_info : public Constant {       // Double
private:

    u4 high_bytes;
    u4 low_bytes;

public:
    CONSTANT_Double_info(ClassReader &reader) : Constant(reader, CONSTANT_Double) {
        high_bytes = reader.readUint32();
        low_bytes = reader.readUint32();
    }

    double get_value() {
        uint64_t bytes = ((uint64_t) high_bytes << 32) + low_bytes;    // first turns to a Long
        if (bytes == DOUBLE_INFINITY) return DOUBLE_INFINITY;
        else if (bytes == DOUBLE_NEGATIVE_INFINITY) return DOUBLE_NEGATIVE_INFINITY;
        else if ((bytes >= 0x7ff0000000000001L && bytes <= 0x7fffffffffffffffL) ||
                 (bytes >= 0xfff0000000000001L && bytes <= 0xffffffffffffffffL))
            return DOUBLE_NAN;
        else {
            int s = ((bytes >> 63) == 0) ? 1 : -1;
            int e = (int) ((bytes >> 52) & 0x7ffL);
            long m = (e == 0) ? (bytes & 0xfffffffffffffL) << 1 : (bytes & 0xfffffffffffffL) | 0x10000000000000L;
            return s * m * pow(2, e - 1075);
        }
    }

};

class CONSTANT_NameAndType_info : public Constant {
public:
    CONSTANT_NameAndType_info(ClassReader &reader_) : Constant(reader_, CONSTANT_NameAndType) {
        name_index = reader_.readUint16();
        descriptor_index = reader_.readUint16();
    }

public:
    u2 name_index;
    u2 descriptor_index;
};

class CONSTANT_Utf8_info : public Constant {       // string literal
public:
    CONSTANT_Utf8_info(ClassReader &reader) : Constant(reader, CONSTANT_Utf8) {
        length = reader.readUint16();
        bytes = reader.readBytes(length);
    }

    u2 length;
    unsigned char *bytes = nullptr;
    std::string str;

    String getConstant() {
        //todo
        return fromBytes(bytes, length);
    }

    ~CONSTANT_Utf8_info();
};

class CONSTANT_MethodHandle_info : public Constant {   // method handler
public:
    CONSTANT_MethodHandle_info(ClassReader &reader) : Constant(reader, CONSTANT_MethodHandle) {
        reference_kind = reader.readUint8();
        reference_index = reader.readUint16();
    }

    u1 reference_kind;
    u2 reference_index;

};

class CONSTANT_MethodType_info : public Constant {   // method type
public:
    CONSTANT_MethodType_info(ClassReader &reader) : Constant(reader, CONSTANT_MethodType) {
        descriptor_index = reader.readUint16();
    }

public:
    u2 descriptor_index;
};

class CONSTANT_InvokeDynamic_info : public Constant {
public:
    u2 bootstrap_method_attr_index;
    u2 name_and_type_index;

    CONSTANT_InvokeDynamic_info(ClassReader &reader) : Constant(reader, CONSTANT_InvokeDynamic) {
        bootstrap_method_attr_index = reader.readUint16();
        name_and_type_index = reader.readUint16();
    }

};


static Constant *readConstant(ClassReader &reader) {
    u1 tag = reader.readUint8();
    switch (tag) {
        case CONSTANT_Integer:
            return new CONSTANT_Integer_info(reader);
        case CONSTANT_Float:
            return new CONSTANT_Float_info(reader);
        case CONSTANT_Long:
            return new CONSTANT_Long_info(reader);
        case CONSTANT_Double:
            return new CONSTANT_Double_info(reader);
        case CONSTANT_Utf8:
            return new CONSTANT_Utf8_info(reader);
        case CONSTANT_Class:
            return new CONSTANT_Class_info(reader);
        case CONSTANT_String:
            return new CONSTANT_String_info(reader);
        case CONSTANT_Fieldref:
            return new ConstantFieldref_info(reader);
        case CONSTANT_Methodref:
            return new ConstantMethodref_info(reader);
        case CONSTANT_InterfaceMethodref:
            return new ConstantInterfaceMethodref_info(reader);
        case CONSTANT_NameAndType:
            return new CONSTANT_NameAndType_info(reader);
        case CONSTANT_MethodType:
            return new CONSTANT_MethodType_info(reader);
        case CONSTANT_MethodHandle:
            return new CONSTANT_MethodHandle_info(reader);
        case CONSTANT_InvokeDynamic:
            return new CONSTANT_InvokeDynamic_info(reader);
        default:
            std::cout << "can't get here, CONSTANT pool." << std::endl;
            assert(false);
    }
}

class ConstantPool {
public:
    ConstantPool(ClassReader &reader) {
        constantPoolCount_ = reader.readUint16();
        constantPool_ = vector<Constant *>(constantPoolCount_);
        for (int i = 0; i < constantPoolCount_ - 1; ++i) {
            constantPool_[i] = readConstant(reader);
            if (constantPool_[i]->tag == CONSTANT_Double || constantPool_[i]->tag == CONSTANT_Long) {
                ++i;
            }
        }
    }

    u2 constantPoolCount_;

    const vector<Constant *> &getConstantPool() const {
        return constantPool_;
    }

private:
    vector<Constant *> constantPool_;
};

static std::unordered_map<String, int> attribute_table{
        {L"ConstantValue",                        0},
        {L"Code",                                 1},
        {L"StackMapTable",                        2},
        {L"Exceptions",                           3},
        {L"InnerClasses",                         4},
        {L"EnclosingMethod",                      5},
        {L"Synthetic",                            6},
        {L"Signature",                            7},
        {L"SourceFile",                           8},
        {L"SourceDebugExtension",                 9},
        {L"LineNumberTable",                      10},
        {L"LocalVariableTable",                   11},
        {L"LocalVariableTypeTable",               12},
        {L"Deprecated",                           13},
        {L"RuntimeVisibleAnnotations",            14},
        {L"RuntimeInvisibleAnnotations",          15},
        {L"RuntimeVisibleParameterAnnotations",   16},
        {L"RuntimeInvisibleParameterAnnotations", 17},
        {L"RuntimeVisibleTypeAnnotations",        18},
        {L"RuntimeInvisibleTypeAnnotations",      19},
        {L"AnnotationDefault",                    20},
        {L"BootstrapMethods",                     21},
        {L"MethodParameters",                     22},
};


class attribute_info {
public:
    u2 attribute_name_index;
    u4 attribute_length;

    attribute_info(ClassReader &reader) {
        attribute_name_index = reader.readUint16();
        attribute_length = reader.readUint32();
    }


};

class ConstantValue_attribute : public attribute_info {
public:
    ConstantValue_attribute(ClassReader &reader) : attribute_info(reader) {
        constantvalue_index = reader.readUint16();
    }

    u2 constantvalue_index;
};

class exception_table_t {
public:
    u2 start_pc;
    u2 end_pc;
    u2 handler_pc;
    u2 catch_type;

    exception_table_t(ClassReader &reader) {
        start_pc = reader.readUint16();
        end_pc = reader.readUint16();
        handler_pc = reader.readUint16();
        catch_type = reader.readUint16();
    }
};

static attribute_info *parseAttribute(ClassReader &reader, ConstantPool *constant_pool);

class Code_attribute : public attribute_info {
public:
    u2 max_stack;
    u2 max_locals;

    u4 code_length;
    u1 *code;

    u2 exception_table_length;
    exception_table_t **exception_table;

    u2 attributes_count;
    attribute_info **attributes;

    Code_attribute(ClassReader &reader, ConstantPool *constantPool) : attribute_info(reader) {
        max_stack = reader.readUint16();
        max_locals = reader.readUint16();
        code_length = reader.readUint32();
        if (code_length != 0) {
            code = new u1[code_length];
            code = reader.readBytes(code_length);
        }
        exception_table_length = reader.readUint16();
        if (exception_table_length != 0) {
            exception_table = new exception_table_t *[exception_table_length];
            for (int pos = 0; pos < exception_table_length; pos++) {
                exception_table[pos] = new exception_table_t(reader);
            }
        }
        attributes_count = reader.readUint16();
        if (attributes_count != 0)
            attributes = new attribute_info *[attributes_count];
        for (int pos = 0; pos < attributes_count; pos++) {
            attributes[pos] = parseAttribute(reader, constantPool);
        }
    }

//    ~Code_attribute() override;

//    void init(ClassFileStream &stream, cp_info **constant_pool);
};

class StackMapTable_attribute : public attribute_info {
public:
    StackMapTable_attribute(ClassReader &reader) : attribute_info(reader) {
        reader.readBytes(attribute_length);
    }
};

class Exceptions_attribute : public attribute_info {
public:
    u2 number_of_exceptions;
    u2 *exception_index_table = nullptr;

    Exceptions_attribute(ClassReader &reader) : attribute_info(reader) {
        number_of_exceptions = reader.readUint16();
        if (number_of_exceptions != 0)
            exception_index_table = new u2[number_of_exceptions];
        for (int pos = 0; pos < number_of_exceptions; pos++) {
            exception_index_table[pos] = reader.readUint16();
        }
    }
};

class InnerClasses_attribute : public attribute_info {
public:
    u2 number_of_classes;

    class classes_t {
    public:
        u2 inner_class_info_index;
        u2 outer_class_info_index;
        u2 inner_name_index;
        u2 inner_class_access_flags;

        classes_t(ClassReader &reader) {
            inner_class_info_index = reader.readUint16();
            outer_class_info_index = reader.readUint16();
            inner_name_index = reader.readUint16();
            inner_class_access_flags = reader.readUint16();
        }
    } **classes = nullptr;

    InnerClasses_attribute(ClassReader &reader) : attribute_info(reader) {
        number_of_classes = reader.readUint16();
        // struct classes_t has no polymorphism. so dont need to define: `struct classes_t **classes`, use `struct classes_t *class` is okay.
        if (number_of_classes != 0)
            classes = new classes_t *[number_of_classes];
        for (int pos = 0; pos < number_of_classes; pos++) {
            classes[pos] = new classes_t(reader);
        }
    }

};

class EnclosingMethod_attribute : public attribute_info {
public:
    u2 class_index;
    u2 method_index;
    EnclosingMethod_attribute(ClassReader &reader) : attribute_info(reader) {
        class_index = reader.readUint16();
        method_index = reader.readUint16();
    }
};

class Synthetic_attribute : public attribute_info {
public:
    Synthetic_attribute(ClassReader &reader) : attribute_info(reader) {}
};

class Signature_attribute : public attribute_info {
public:
    u2 signature_index;

    Signature_attribute(ClassReader &reader) : attribute_info(reader) {
        signature_index = reader.readUint16();
    }
};

class SourceFile_attribute : public attribute_info {
public:
    u2 sourcefile_index;
    SourceFile_attribute(ClassReader &reader) : attribute_info(reader) {
        sourcefile_index = reader.readUint16();
    }
};

class SourceDebugExtension_attribute : public attribute_info {
public:
    u1 *debug_extension = nullptr;        // [attribute_length];
    SourceDebugExtension_attribute(ClassReader &reader) : attribute_info(reader) {
        if (attribute_length != 0)
            debug_extension = new u1[attribute_length];
        debug_extension = reader.readBytes(attribute_length);
    }
};


class LineNumberTable_attribute : public attribute_info {
public:
    u2 line_number_table_length;

    class line_number_table_t {
    public:
        u2 start_pc;
        u2 line_number;

        line_number_table_t(ClassReader &reader) {
            start_pc = reader.readUint16();
            line_number = reader.readUint16();
        }
    } **line_number_table = nullptr;        // [line_number_table_length]

    LineNumberTable_attribute(ClassReader &reader) : attribute_info(reader) {
        line_number_table_length = reader.readUint16();
        if (line_number_table_length != 0)
            line_number_table = new LineNumberTable_attribute::line_number_table_t *[line_number_table_length];
        for (int pos = 0; pos < line_number_table_length; pos++) {
            line_number_table[pos] = new LineNumberTable_attribute::line_number_table_t(reader);
        }
    }
};

class LocalVariableTable_attribute : public attribute_info {
public:
    u2 local_variable_table_length;

    class local_variable_table_t {
        u2 start_pc;
        u2 length;
        u2 name_index;
        u2 descriptor_index;
        u2 index;
    public:
        local_variable_table_t(ClassReader &reader) {
            start_pc = reader.readUint16();
            length = reader.readUint16();
            name_index = reader.readUint16();
            descriptor_index = reader.readUint16();
            index = reader.readUint16();
        }

    } **local_variable_table = nullptr;    // [local_variable_table_length]
    LocalVariableTable_attribute(ClassReader &reader) : attribute_info(reader) {
        local_variable_table_length = reader.readUint16();
        if (local_variable_table_length != 0)
            local_variable_table = new LocalVariableTable_attribute::local_variable_table_t *[local_variable_table_length];
        for (int pos = 0; pos < local_variable_table_length; pos++) {
            local_variable_table[pos] = new LocalVariableTable_attribute::local_variable_table_t(reader);
        }
    }
};

class LocalVariableTypeTable_attribute : public attribute_info {
public:
    u2 local_variable_type_table_length;

    class local_variable_type_table_t {
    public:
        u2 start_pc;
        u2 length;
        u2 name_index;
        u2 signature_index;
        u2 index;

        local_variable_type_table_t(ClassReader &reader) {
            start_pc = reader.readUint16();
            length = reader.readUint16();
            name_index = reader.readUint16();
            signature_index = reader.readUint16();
            index = reader.readUint16();
        }
    } **local_variable_type_table = nullptr;// [local_variable_type_table_length]
    LocalVariableTypeTable_attribute(ClassReader &reader) : attribute_info(reader) {
        local_variable_type_table_length = reader.readUint16();
        if (local_variable_type_table_length != 0)
            local_variable_type_table = new LocalVariableTypeTable_attribute::local_variable_type_table_t *[local_variable_type_table_length];
        for (int pos = 0; pos < local_variable_type_table_length; pos++) {
            local_variable_type_table[pos] = new local_variable_type_table_t(reader);
        }
    }

};

class Deprecated_attribute : public attribute_info {
public:
    Deprecated_attribute(ClassReader &reader) : attribute_info(reader) {

    }
};


class CodeStub {
public:
    std::vector<u1> stub;

    void inject(u1 code) {
        stub.push_back(code);
    }

    void inject(u2 code) {
        inject((u1) ((code >> 8) & 0xFF));
        inject((u1) (code & 0xFF));
    }

    void inject(u4 code) {
        inject((u1) ((code >> 24) & 0xFF));
        inject((u1) ((code >> 16) & 0xFF));
        inject((u1) ((code >> 8) & 0xFF));
        inject((u1) (code & 0xFF));
    }

    void inject(u1 *bytes, int num) {
        for (int i = 0; i < num; i++) {
            inject((u1) bytes[i]);
        }
    }

    void inject(u2 *bytes, int num) {
        for (int i = 0; i < num; i++) {
            inject((u2) bytes[i]);
        }
    }

    CodeStub &operator+=(const CodeStub &rhs) {
        this->stub.insert(this->stub.end(), rhs.stub.begin(), rhs.stub.end());
        return *this;
    }

    CodeStub operator+(const CodeStub &rhs) {
        CodeStub tmp;
        tmp += *this;
        tmp += rhs;
        return tmp;
    }

    void print() {
        std::wcout << "===---------------- CodeStub -------------------===" << std::endl;
        for (int i = 0; i < stub.size(); i++) {
            std::wcout << std::hex << (unsigned) stub[i] << " ";
            if ((i + 1) % 8 == 0) std::wcout << std::endl;
        }
        std::wcout << std::endl;
        std::wcout << "===---------------------------------------------===" << std::endl;
    }
};

class value_t {
public:
    CodeStub stub;

    virtual ~value_t() {}
};

class const_value_t : public value_t {
public:
    u2 const_value_index;

    const_value_t(ClassReader &reader) {
        const_value_index = reader.readUint16();
        stub.inject(const_value_index);
    }
};

class class_info_t : public value_t {
public:
    u2 class_info_index;

    class_info_t(ClassReader &reader) {
        class_info_index = reader.readUint16();
        stub.inject(class_info_index);
    }

};

class enum_const_value_t : public value_t {
public:
    enum_const_value_t(ClassReader &reader) {
        type_name_index = reader.readUint16();
        const_name_index = reader.readUint16();
        stub.inject(type_name_index);
        stub.inject(const_name_index);
    }

    u2 type_name_index;
    u2 const_name_index;
};


class element_value {
public:
    u1 tag;
    value_t *value = nullptr;    // [1]
    CodeStub stub;

    element_value(ClassReader &reader);
};


class array_value_t : public value_t {
public:
    u2 num_values;
    element_value **values = nullptr;        // [num_values]

    array_value_t(ClassReader &reader) {
        num_values = reader.readUint16();
        if (num_values !=
            0)        // 这里写成了 values...... 本来就是 nullptr 是 0 ....... 结果调了一个小时...... 一直显示在下边 f >> values[pos] 进入函数中的第一行出错...... 唉（ 还以为是标准库错了（逃 我真是个白痴（打脸
            values = new element_value *[num_values];
        for (int pos = 0; pos < num_values; pos++) {
            values[pos] = new element_value(reader);
        }
        // CodeStub
        stub.inject(num_values);
        for (int pos = 0; pos < num_values; pos++) {
            stub += values[pos]->stub;
        }
    }
};

class annotation : public value_t {
public:
    annotation(ClassReader &reader) : value_t() {
        type_index = reader.readUint16();
        num_element_value_pairs = reader.readUint16();
        if (num_element_value_pairs != 0)
            element_value_pairs = new annotation::element_value_pairs_t *[num_element_value_pairs];
        for (int pos = 0; pos < num_element_value_pairs; pos++) {
            element_value_pairs[pos] = new annotation::element_value_pairs_t(reader);
        }
        // CodeStub
        stub.inject(type_index);
        stub.inject(num_element_value_pairs);
        for (int pos = 0; pos < num_element_value_pairs; pos++) {
            stub += element_value_pairs[pos]->stub;
        }
    }

    u2 type_index;
    u2 num_element_value_pairs;

    class element_value_pairs_t {
    public:
        element_value_pairs_t(ClassReader &reader) {
            element_name_index = reader.readUint16();
//            f >> value;
            value = new element_value(reader);
            // CodeStub
            stub.inject(element_name_index);
            stub += value->stub;
        }

        u2 element_name_index;
        element_value *value;

        CodeStub stub;
    } **element_value_pairs = nullptr;        // [num_element_value_pairs]


};


class parameter_annotations_t {    // extract from Runtime_XXX_Annotations_attributes
public:
    parameter_annotations_t(ClassReader &reader) {
        num_annotations = reader.readUint16();
        if (num_annotations != 0)
            annotations = new annotation *[num_annotations];
        for (int pos = 0; pos < num_annotations; pos++) {
            annotations[pos] = new annotation(reader);
        }
        // CodeStub
        stub.inject(num_annotations);
        for (int pos = 0; pos < num_annotations; pos++) {
            stub += annotations[pos]->stub;
        }
    }

    u2 num_annotations;
    annotation **annotations = nullptr;    // [num_annotations]


    CodeStub stub;
};

class RuntimeVisibleAnnotations_attribute : public attribute_info {
public:
    parameter_annotations_t parameter_annotations;

    RuntimeVisibleAnnotations_attribute(ClassReader &reader) : attribute_info(reader), parameter_annotations(reader) {
    }
};

class RuntimeInvisibleAnnotations_attribute : public attribute_info {
public:
    parameter_annotations_t *parameter_annotations;

    RuntimeInvisibleAnnotations_attribute(ClassReader &reader) : attribute_info(reader) {
        parameter_annotations = new parameter_annotations_t(reader);
    }
};

class RuntimeVisibleParameterAnnotations_attribute : public attribute_info {
public:
    u1 num_parameters;
    parameter_annotations_t **parameter_annotations = nullptr;        // [num_parameters];
    CodeStub stub;

    RuntimeVisibleParameterAnnotations_attribute(ClassReader &reader) : attribute_info(reader) {
        num_parameters = reader.readUint8();
        if (num_parameters != 0)
            parameter_annotations = new parameter_annotations_t *[num_parameters];
        for (int pos = 0; pos < num_parameters; pos++) {
            parameter_annotations[pos] = new parameter_annotations_t(reader);
        }
        // check
        int total_anno_length = 0;
        total_anno_length += 1;
        for (int pos = 0; pos < num_parameters; pos++) {
            total_anno_length += parameter_annotations[pos]->stub.stub.size();
        }
        assert(attribute_length == total_anno_length);
        // CodeStub
        stub.inject(num_parameters);
        for (int pos = 0; pos < num_parameters; pos++) {
            stub += parameter_annotations[pos]->stub;
        }
    }
};

class RuntimeInvisibleParameterAnnotations_attribute : public attribute_info {
public:
    u1 num_parameters;
    parameter_annotations_t **parameter_annotations = nullptr;        // [num_parameters];
    friend std::istream &operator>>(std::istream &f, RuntimeInvisibleParameterAnnotations_attribute &i);

    ~RuntimeInvisibleParameterAnnotations_attribute();

    RuntimeInvisibleParameterAnnotations_attribute(ClassReader &reader) : attribute_info(reader) {
        num_parameters = reader.readUint8();
        if (num_parameters != 0)
            parameter_annotations = new parameter_annotations_t *[num_parameters];
        for (int pos = 0; pos < num_parameters; pos++) {
            parameter_annotations[pos] = new parameter_annotations_t(reader);
        }
        // check
        int total_anno_length = 0;
        total_anno_length += 1;
        for (int pos = 0; pos < num_parameters; pos++) {
            total_anno_length += parameter_annotations[pos]->stub.stub.size();
        }
        assert(attribute_length == total_anno_length);
    }
};
struct type_annotation {
    // target_type
    struct target_info_t {
        CodeStub stub;
        virtual ~target_info_t() {}
    };
    struct type_parameter_target : target_info_t {
        u1 type_parameter_index;
        friend std::istream & operator >> (std::istream & f, type_annotation::type_parameter_target & i);
    };
    struct supertype_target : target_info_t {
        u2 supertype_index;
        friend std::istream & operator >> (std::istream & f, type_annotation::supertype_target & i);
    };
    struct type_parameter_bound_target : target_info_t {
        u1 type_parameter_index;
        u1 bound_index;
        friend std::istream & operator >> (std::istream & f, type_annotation::type_parameter_bound_target & i);
    };
    struct empty_target : target_info_t {
        friend std::istream & operator >> (std::istream & f, type_annotation::empty_target & i);
    };
    struct formal_parameter_target : target_info_t {
        u1 formal_parameter_index;
        friend std::istream & operator >> (std::istream & f, type_annotation::formal_parameter_target & i);
    };
    struct throws_target : target_info_t {
        u2 throws_type_index;
        friend std::istream & operator >> (std::istream & f, type_annotation::throws_target & i);
    };
    struct localvar_target : target_info_t {
        u2 table_length;
        struct table_t {
            u2 start_pc;
            u2 length;
            u2 index;
            friend std::istream & operator >> (std::istream & f, type_annotation::localvar_target::table_t & i);
            CodeStub stub;
        } *table = nullptr;				// [table_length];
        friend std::istream & operator >> (std::istream & f, type_annotation::localvar_target & i);
        ~localvar_target();
    };
    struct catch_target : target_info_t {
        u2 exception_table_index;
        friend std::istream & operator >> (std::istream & f, type_annotation::catch_target & i);
    };
    struct offset_target : target_info_t {
        u2 offset;
        friend std::istream & operator >> (std::istream & f, type_annotation::offset_target & i);
    };
    struct type_argument_target : target_info_t {
        u2 offset;
        u1 type_argument_index;
        friend std::istream & operator >> (std::istream & f, type_annotation::type_argument_target & i);
    };
    // type_path
    struct type_path {
        u1 path_length;
        struct path_t {
            u1 type_path_kind;
            u1 type_argument_index;
            friend std::istream & operator >> (std::istream & f, type_annotation::type_path::path_t & i);
            CodeStub stub;
        } *path = nullptr;				// [path_length];
        friend std::istream & operator >> (std::istream & f, type_annotation::type_path & i);
        ~type_path();
        CodeStub stub;
    };

    // basic
    u1 target_type;
    target_info_t *target_info = nullptr;	// [1]
    type_path target_path;
    annotation *anno = nullptr;				// [1]

    friend std::istream & operator >> (std::istream & f, type_annotation & i);
    ~type_annotation();
    CodeStub stub;
};
class RuntimeVisibleTypeAnnotations_attribute : public attribute_info {
public:
    RuntimeVisibleTypeAnnotations_attribute(ClassReader &reader) : attribute_info(reader) {
        reader.readBytes(attribute_length);
    }

    u2 num_annotations;
    type_annotation *annotations = nullptr;					// [num_annotations];
};

class RuntimeInvisibleTypeAnnotations_attribute : public attribute_info {
public:
    RuntimeInvisibleTypeAnnotations_attribute(ClassReader &reader) : attribute_info(reader) {
        reader.readBytes(attribute_length);
    }

//    u2 num_annotations;
////    type_annotation *annotations = nullptr;					// [num_annotations];
//    friend std::istream & operator >> (std::istream & f, RuntimeInvisibleTypeAnnotations_attribute & i);
//    ~RuntimeInvisibleTypeAnnotations_attribute();
};

class AnnotationDefault_attribute : public attribute_info {
public:
    AnnotationDefault_attribute(ClassReader &reader) : attribute_info(reader) {
        default_value = new element_value(reader);
        stub += default_value->stub;
    }

    element_value *default_value;

    CodeStub stub;
};

class BootstrapMethods_attribute : public attribute_info {
public:
    BootstrapMethods_attribute(ClassReader &reader) : attribute_info(reader) {
        num_bootstrap_methods = reader.readUint16();
        if (num_bootstrap_methods != 0)
            bootstrap_methods = new BootstrapMethods_attribute::bootstrap_methods_t *[num_bootstrap_methods];
        for (int pos = 0; pos < num_bootstrap_methods; pos++) {
            bootstrap_methods[pos] = new BootstrapMethods_attribute::bootstrap_methods_t(reader);
        }
    }

    u2 num_bootstrap_methods;

    class bootstrap_methods_t {
    public:
        u2 bootstrap_method_ref;
        u2 num_bootstrap_arguments;
        u2 *bootstrap_arguments = nullptr;                    // [num_bootstrap_arguments];
        bootstrap_methods_t(ClassReader &reader) {
            bootstrap_method_ref = reader.readUint16();
            num_bootstrap_arguments = reader.readUint16();
            if (num_bootstrap_arguments != 0)
                bootstrap_arguments = new u2[num_bootstrap_arguments];
            for (int pos = 0; pos < num_bootstrap_arguments; pos++) {
                bootstrap_arguments[pos] = reader.readUint16();
            }
        }

    private:
        ~bootstrap_methods_t();
    } **bootstrap_methods = nullptr;                            // [num_bootstrap_methods];
};

class MethodParameters_attribute : public attribute_info {
public:
    u1 parameters_count;

    class parameters_t {
    public:
        u2 name_index;
        u2 access_flags;

        parameters_t(ClassReader &reader) {
            name_index = reader.readUint16();
            access_flags = reader.readUint16();
        }
    } **parameters = nullptr;                                    // [parameters_count];
    MethodParameters_attribute(ClassReader &reader) : attribute_info(reader) {
        parameters_count = reader.readUint8();
        if (parameters_count != 0)
            parameters = new MethodParameters_attribute::parameters_t *[parameters_count];
        for (int pos = 0; pos < parameters_count; pos++) {
            parameters[pos] = new MethodParameters_attribute::parameters_t(reader);
        }
    }

    ~MethodParameters_attribute();
};


class field_info {
public:
    field_info(ClassReader &reader, ConstantPool *constantPool) {
        access_flags = reader.readUint16();
        name_index = reader.readUint16();
        descriptor_index = reader.readUint16();
        attributes_count = reader.readUint16();
        if (attributes_count != 0)        // !!!!! attention !!!!!
            attributes = new attribute_info *[attributes_count];
        for (int pos = 0; pos < attributes_count; pos++) {
            attributes[pos] = parseAttribute(reader, constantPool);
        }
    }

    u2 access_flags;
    u2 name_index;
    u2 descriptor_index;
    u2 attributes_count;
    attribute_info **attributes = nullptr;        // [attributes_count]
    ~field_info() {
        if (attributes != nullptr) {
            for (int i = 0; i < attributes_count; i++) {
                delete attributes[i];
            }
            delete[] attributes;
        }
    }
};

class method_info {
public:
    method_info(ClassReader &reader, ConstantPool *constantPool, int a) {
        access_flags = reader.readUint16();
        name_index = reader.readUint16();
        descriptor_index = reader.readUint16();
        attributes_count = reader.readUint16();

        if (attributes_count != 0)
            attributes = new attribute_info *[attributes_count];
        for (int pos = 0; pos < attributes_count; pos++) {
            attributes[pos] = parseAttribute(reader, constantPool);
        }
    }

    u2 access_flags;
    u2 name_index;
    u2 descriptor_index;
    u2 attributes_count;
    attribute_info **attributes = nullptr;        // [attributes_count]
};

class ClassFile {
public:
    ClassFile(const std::string &filePath) : reader(filePath) {
    }

    u4 magic = 0;
    u2 minor_version = 0;
    u2 major_version = 0;
    ConstantPool *constantPool;
    u2 access_flags = 0;
    u2 this_class = 0;
    u2 super_class = 0;
    u2 interfaces_count = 0;
    u2 *interfaces = nullptr;                // [interfaces_count]
    u2 fields_count = 0;

    field_info **fields = nullptr;            // [fields_count]
    u2 methods_count = 0;
    method_info **methods = nullptr;            // [methods_count];
    u2 attributes_count = 0;
    attribute_info **attributes = nullptr;    // [attributes_count];
    void parse();

private:


    ClassReader reader;

    void readMagic();

    void readVersion();

    void readConstantPool();

    void readClassInfo();

    void readInterfaces();

    void readFields();

    void readMethods();

    void readAttributes();


    void parse_class_msgs();

    void parse_interfaces();

    void parse_fields();

    void parse_methods();

    void parse_attributes();
};

u2 toAttributeTag(u2 attribute_name_index,
                  ConstantPool *constant_pool);
void print_methods(method_info **bufs, int length, ConstantPool *constant_pool) ;

#endif //TINY_JVM_CLASSFILE_PARSER_H

